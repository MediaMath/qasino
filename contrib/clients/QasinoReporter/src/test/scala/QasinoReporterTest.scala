import org.scalatest._
import mediamath.metrics._
import com.codahale.metrics._
import com.fasterxml.jackson.module.scala._
import com.fasterxml.jackson.databind.ObjectMapper
import collection._

class QasinoReporterTest extends FlatSpec with Matchers {
	// name sanitization checks
	val sep = QasinoReporter.registryNameSeparator
	"A sanitized registry name" should "replace non-alphanumeric characters with underscores" in {
		QasinoReporter.sanitizeRegistryName("testing.abc") should be ("testing" + sep + "abc")
	}
	it should "change all uppercase characters to lowercase" in {
		QasinoReporter.sanitizeRegistryName("tEsT") should be ("test")
	}

	"The QasinoReporterBuilder" should "throw an IllegalArgumentException if two metrics are built with names that are the same after sanitation" in {
		val counter1 = new Counter
		val counter1name = "testing_abc"
		val counter2 = new Counter
		val counter2name = "testing.abc"
		val metrics = new MetricRegistry
		metrics.register(MetricRegistry.name(counter1name), counter1)
		metrics.register(MetricRegistry.name(counter2name), counter2)
		intercept[IllegalArgumentException] {
			new QasinoReporterBuilder().withRegistry(metrics).build()
		}
	}

	it should "throw an IllegalArgumentException if a suffix (column name) begins with a non-alpha character" in {
		val counter1 = new Counter
		val counter1name = "testing_123"
		val metrics = new MetricRegistry
		metrics.register(MetricRegistry.name(counter1name), counter1)
		intercept[IllegalArgumentException] {
			new QasinoReporterBuilder().withRegistry(metrics).withGroupings(Set("testing")).build()
		}
	}

	{
		// JSON validation
		val mapper = new ObjectMapper()
		mapper.registerModule(DefaultScalaModule)
		val counter1 = new Counter
		val counter1name = "testing_abc"
		val counter2 = new Counter
		counter2.inc(100)
		val counter2name = "testing_def"
		val metrics = new MetricRegistry
		metrics.register(MetricRegistry.name(counter1name), counter1)
		metrics.register(MetricRegistry.name(counter2name), counter2)
		"The JSON generated by two separated metrics" should "be reported separately" in {
			val groupPrefix = "nothing_in_common"
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGroupings(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(SortedMap[String, Metric](counter1name -> counter1, counter2name -> counter2))
			assert(jsonStrSeq.size === 2)
		}
		"The JSON generated by two metrics with the same group" should "be reported together" in {
			val groupPrefix = "testing"
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGroupings(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(SortedMap[String, Metric](counter1name -> counter1, counter2name -> counter2))
			assert(jsonStrSeq.size === 1)
		}
		// Check JSON values
		{
			class IntGauge(value: Int) extends Gauge[Int] {
				def getValue = value
			}

			metrics.register("testing_gauge", new IntGauge(100))
			metrics.register("testing_meter", new Meter())
			metrics.register("testing_timer", new Timer())
			val groupPrefix = "testing"
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGroupings(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(reporter.combineMetricsToMap())
			val dataMap = mapper.readValue(jsonStrSeq(0), classOf[Map[String, Any]])
			val tableDataMap = dataMap.getOrElse("table", {}).asInstanceOf[Map[String, Any]]
			"The op value" should "be add_table_data" in {
				assert("add_table_data" === dataMap("op"))
			}
			"The tablename value" should "be " + groupPrefix in {
				assert(groupPrefix === tableDataMap("tablename"))
			}
			val correctColumnNames = List("abc_count", "def_count", "gauge_value", "meter_fifteen_minute_rate", "meter_five_minute_rate", "meter_mean_rate", "meter_one_minute_rate", "timer_fifteen_minute_rate", "timer_five_minute_rate", "timer_mean_rate", "timer_one_minute_rate")
			"The column_names" should "be " + correctColumnNames in {
				assert(tableDataMap("column_names") === correctColumnNames)
			}
			val correctColumnTypes = List("int", "int", "int", "int", "int", "string", "int", "int", "int", "int", "int")
			"The column_types" should "be " + correctColumnTypes in {
				assert(tableDataMap("column_types") === correctColumnTypes)
			}
		}
	}
}
