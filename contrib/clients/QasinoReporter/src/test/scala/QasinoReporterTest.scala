/**
 * Created by dpowell on 1/29/14.
 */

import org.scalatest._
import mediamath.metrics._
import com.codahale.metrics._
import com.fasterxml.jackson.module.scala._
import com.fasterxml.jackson.databind.ObjectMapper
import collection._
import java.lang.reflect.{Type, ParameterizedType}

class QasinoReporterTest extends FlatSpec with Matchers {
	// name sanitization checks
	val sep = QasinoReporter.registryNameSeparator
	"A sanitized registry name" should "replace non-alphanumeric characters with underscores" in {
		QasinoReporter.sanitizeRegistryName("testing.123") should be ("testing" + sep + "123")
	}
	it should "change all uppercase characters to lowercase" in {
		QasinoReporter.sanitizeRegistryName("tEsT") should be ("test")
	}

	"The QasinoReporterBuilder" should "throw an IllegalArgumentException if two metrics are built with names that are the same after sanitation" in {
		val counter1 = new Counter
		val counter1name = "testing_123"
		val counter2 = new Counter
		val counter2name = "testing.123"
		val metrics = new MetricRegistry
		metrics.register(MetricRegistry.name(counter1name), counter1)
		metrics.register(MetricRegistry.name(counter2name), counter2)
		intercept[IllegalArgumentException] {
			new QasinoReporterBuilder().withRegistry(metrics).build()
		}
	}

	{
		// JSON validation
		val mapper = new ObjectMapper()
		mapper.registerModule(DefaultScalaModule)
		val counter1 = new Counter
		val counter1name = "testing_123"
		val counter2 = new Counter
		counter2.inc(100)
		val counter2name = "testing_456"
		val metrics = new MetricRegistry
		metrics.register(MetricRegistry.name(counter1name), counter1)
		metrics.register(MetricRegistry.name(counter2name), counter2)
		"The JSON generated by two separated metrics" should "be reported separately" in {
			val groupPrefix = "nothing_in_common"
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGaugeGroups(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(SortedMap[String, Metric](counter1name -> counter1, counter2name -> counter2))
			assert(jsonStrSeq.size === 2)
		}
		"The JSON generated by two metrics with the same group" should "be reported together" in {
			val groupPrefix = "testing"
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGaugeGroups(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(SortedMap[String, Metric](counter1name -> counter1, counter2name -> counter2))
			assert(jsonStrSeq.size === 1)
		}
		// Check JSON values
		{
			val groupPrefix = "testing"
			val prefixLen = groupPrefix.length + 1
			val reporter = new QasinoReporterBuilder().withRegistry(metrics).withGaugeGroups(Set(groupPrefix)).build()
			val jsonStrSeq = reporter.getJsonForMetrics(SortedMap[String, Metric](counter1name -> counter1, counter2name -> counter2))
			val dataMap = mapper.readValue(jsonStrSeq(0), classOf[Map[String, Any]])
			"The op value " should "be add_table_data" in {
				assert(dataMap("op") === "add_table_data")
			}
			"The tablename value" should "be " + groupPrefix in {
				assert(dataMap("tablename") === groupPrefix)
			}
			"The column_names" should "be [int, int]" in {
				assert(dataMap("column_names") === List(counter1name.drop(prefixLen) + "_count", counter2name.drop(prefixLen) + "_count"))
			}
			"The column_types" should "be [count, count]" in {
				assert(dataMap("column_types") === List("int", "int"))
			}
			"The rows" should "be [0, 100]" in {
				assert(dataMap("rows") === List(0, 100))
			}
		}
	}

	//{
	//	// TODO: make a test that shows we can add all different types
	//	//class IntGauge(value: Int) extends Gauge[Int] {
	//	//	def getValue = value
	//	//}
	//	val metrics = new MetricRegistry
	//	val gauge1 = metrics.register("gauge1", new IntGauge(100) extends Gauge[Int] {
	//		override def getValue = value
	//	})
	//	}
	//	val histogram1 = new Histogram()
	//	val meter1 = new Meter()
	//	val timer1 = new Timer()
	//}
}
